<application>
  <component name="AppStorage">
    <histories>
      <item value="/** * This interface represents the abstract notion of a principal, which * can be used to represent any entity, such as an individual, a * corporation, and a login id. * * @see java.security.cert.X509Certificate * * @author Li Gong */" />
      <item value="/** * Returns true if the specified subject is implied by this principal. * * &lt;p&gt;The default implementation of this method returns true if * {@code subject} is non-null and contains at least one principal that * is equal to this principal. * * &lt;p&gt;Subclasses may override this with a different implementation, if * necessary. * * @param subject the {@code Subject} * @return true if {@code subject} is non-null and is * implied by this principal, or false otherwise. * @since 1.8 */" />
      <item value="/** * Represents the token for an authentication request or for an authenticated principal * once the request has been processed by the * {@link AuthenticationManager#authenticate(Authentication)} method. * &lt;p&gt; * Once the request has been authenticated, the &lt;tt&gt;Authentication&lt;/tt&gt; will usually be * stored in a thread-local &lt;tt&gt;SecurityContext&lt;/tt&gt; managed by the * {@link SecurityContextHolder} by the authentication mechanism which is being used. An * explicit authentication can be achieved, without using one of Spring Security's * authentication mechanisms, by creating an &lt;tt&gt;Authentication&lt;/tt&gt; instance and using * the code: * * &lt;pre&gt; * SecurityContextHolder.getContext().setAuthentication(anAuthentication); * &lt;/pre&gt; * * Note that unless the &lt;tt&gt;Authentication&lt;/tt&gt; has the &lt;tt&gt;authenticated&lt;/tt&gt; property * set to &lt;tt&gt;true&lt;/tt&gt;, it will still be authenticated by any security interceptor (for * method or web invocations) which encounters it. * &lt;p&gt; * In most cases, the framework transparently takes care of managing the security context * and authentication objects for you. * * @author Ben Alex */" />
      <item value="/* * Copyright 2004, 2005, 2006 Acegi Technology Pty Limited * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.security.core; import java.io.Serializable;&#10;import java.security.Principal;&#10;import java.util.Collection; import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.core.context.SecurityContextHolder; /** * Represents the token for an authentication request or for an authenticated principal * once the request has been processed by the * {@link AuthenticationManager#authenticate(Authentication)} method. * &lt;p&gt; * Once the request has been authenticated, the &lt;tt&gt;Authentication&lt;/tt&gt; will usually be * stored in a thread-local &lt;tt&gt;SecurityContext&lt;/tt&gt; managed by the * {@link SecurityContextHolder} by the authentication mechanism which is being used. An * explicit authentication can be achieved, without using one of Spring Security's * authentication mechanisms, by creating an &lt;tt&gt;Authentication&lt;/tt&gt; instance and using * the code: * * &lt;pre&gt; * SecurityContextHolder.getContext().setAuthentication(anAuthentication); * &lt;/pre&gt; * * Note that unless the &lt;tt&gt;Authentication&lt;/tt&gt; has the &lt;tt&gt;authenticated&lt;/tt&gt; property * set to &lt;tt&gt;true&lt;/tt&gt;, it will still be authenticated by any security interceptor (for * method or web invocations) which encounters it. * &lt;p&gt; * In most cases, the framework transparently takes care of managing the security context * and authentication objects for you. * * @author Ben Alex */&#10;public interface Authentication extends Principal, Serializable { // ~ Methods // ======================================================================================================== /** * Set by an &lt;code&gt;AuthenticationManager&lt;/code&gt; to indicate the authorities that the * principal has been granted. Note that classes should not rely on this value as * being valid unless it has been set by a trusted &lt;code&gt;AuthenticationManager&lt;/code&gt;. * &lt;p&gt; * Implementations should ensure that modifications to the returned collection array * do not affect the state of the Authentication object, or use an unmodifiable * instance. * &lt;/p&gt; * * @return the authorities granted to the principal, or an empty collection if the * token has not been authenticated. Never null. */ Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); /** * The credentials that prove the principal is correct. This is usually a password, * but could be anything relevant to the &lt;code&gt;AuthenticationManager&lt;/code&gt;. Callers * are expected to populate the credentials. * * @return the credentials that prove the identity of the &lt;code&gt;Principal&lt;/code&gt; */ Object getCredentials(); /** * Stores additional details about the authentication request. These might be an IP * address, certificate serial number etc. * * @return additional details about the authentication request, or &lt;code&gt;null&lt;/code&gt; * if not used */ Object getDetails(); /** * The identity of the principal being authenticated. In the case of an authentication * request with username and password, this would be the username. Callers are * expected to populate the principal for an authentication request. * &lt;p&gt; * The &lt;tt&gt;AuthenticationManager&lt;/tt&gt; implementation will often return an * &lt;tt&gt;Authentication&lt;/tt&gt; containing richer information as the principal for use by * the application. Many of the authentication providers will create a * {@code UserDetails} object as the principal. * * @return the &lt;code&gt;Principal&lt;/code&gt; being authenticated or the authenticated * principal after authentication. */ Object getPrincipal(); /** * Used to indicate to {@code AbstractSecurityInterceptor} whether it should present * the authentication token to the &lt;code&gt;AuthenticationManager&lt;/code&gt;. Typically an * &lt;code&gt;AuthenticationManager&lt;/code&gt; (or, more often, one of its * &lt;code&gt;AuthenticationProvider&lt;/code&gt;s) will return an immutable authentication token * after successful authentication, in which case that token can safely return * &lt;code&gt;true&lt;/code&gt; to this method. Returning &lt;code&gt;true&lt;/code&gt; will improve * performance, as calling the &lt;code&gt;AuthenticationManager&lt;/code&gt; for every request * will no longer be necessary. * &lt;p&gt; * For security reasons, implementations of this interface should be very careful * about returning &lt;code&gt;true&lt;/code&gt; from this method unless they are either * immutable, or have some way of ensuring the properties have not been changed since * original creation. * * @return true if the token has been authenticated and the * &lt;code&gt;AbstractSecurityInterceptor&lt;/code&gt; does not need to present the token to the * &lt;code&gt;AuthenticationManager&lt;/code&gt; again for re-authentication. */ boolean isAuthenticated(); /** * See {@link #isAuthenticated()} for a full description. * &lt;p&gt; * Implementations should &lt;b&gt;always&lt;/b&gt; allow this method to be called with a * &lt;code&gt;false&lt;/code&gt; parameter, as this is used by various classes to specify the * authentication token should not be trusted. If an implementation wishes to reject * an invocation with a &lt;code&gt;true&lt;/code&gt; parameter (which would indicate the * authentication token is trusted - a potential security risk) the implementation * should throw an {@link IllegalArgumentException}. * * @param isAuthenticated &lt;code&gt;true&lt;/code&gt; if the token should be trusted (which may * result in an exception) or &lt;code&gt;false&lt;/code&gt; if the token should not be trusted * * @throws IllegalArgumentException if an attempt to make the authentication token * trusted (by passing &lt;code&gt;true&lt;/code&gt; as the argument) is rejected due to the * implementation being immutable or implementing its own alternative approach to * {@link #isAuthenticated()} */ void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;&#10;}" />
      <item value="simply" />
      <item value="Authenticator" />
      <item value="deprecation" />
      <item value="milliseconds" />
      <item value="/** * Set the underlying connect timeout in milliseconds. * A value of 0 specifies an infinite timeout. */" />
      <item value="/** * Equivalent to * {@link #convert(long, TimeUnit) MILLISECONDS.convert(duration, this)}. * @param duration the duration * @return the converted duration, * or {@code Long.MIN_VALUE} if conversion would negatively * overflow, or {@code Long.MAX_VALUE} if it would positively overflow. */" />
      <item value="/** * If you specify a static constructor name, then the generated constructor will be private, and * instead a static factory method is created that other classes can use to create instances. * We suggest the name: &quot;of&quot;, like so: * * &lt;pre&gt; * public @Data(staticConstructor = &quot;of&quot;) class Point { final int x, y; } * &lt;/pre&gt; * * Default: No static constructor, instead the normal constructor is public. * * @return Name of static 'constructor' method to generate (blank = generate a normal constructor). */" />
      <item value="/** * Only include fields and methods explicitly marked with {@code @EqualsAndHashCode.Include}. * Normally, all (non-static, non-transient) fields are included by default. * * @return If {@code true}, don't include non-static non-transient fields automatically (default: {@code false}). */" />
      <item value="/** * If present, explicitly lists the fields that are to be used for identity. * Normally, all non-static, non-transient fields are used for identity. * &lt;p&gt; * Mutually exclusive with {@link #exclude()}. * &lt;p&gt; * Will soon be marked {@code @Deprecated}; use the {@code @EqualsAndHashCode.Include} annotation together with {@code @EqualsAndHashCode(onlyExplicitlyIncluded = true)}. * * @return A list of fields to use (&lt;em&gt;default&lt;/em&gt;: all of them). */" />
      <item value="/** * Defaults to the method name of the annotated member. * If on a method and the name equals the name of a default-included field, this member takes its place. * * @return If present, this method serves as replacement for the named field. */" />
      <item value="/** * Any fields listed here will not be taken into account in the generated {@code equals} and {@code hashCode} implementations. * Mutually exclusive with {@link #of()}. * &lt;p&gt; * Will soon be marked {@code @Deprecated}; use the {@code @EqualsAndHashCode.Exclude} annotation instead. * * @return A list of fields to exclude. */" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="18" />
        <entry key="ENGLISH" value="19" />
      </map>
    </option>
  </component>
</application>